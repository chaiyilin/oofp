<div class="text-lg-left">
    <ul>
        <li>
            OO makes code understandable by encapsulating moving parts
        </li>
        <li>
            FP makes code understandable by minimizing moving parts
        </li>
    </ul>
</div>

<div class="text-lg-left with-top-margin">
    <strong class="red">abstract control flows</strong> and
    <strong class="red">operations on data with functions</strong> in order to
    <strong class="red">avoid side effects</strong> and
    <strong class="red">reduce mutation of state (statelessness and immutability)</strong> in your application
</div>

<div class="text-lg-left with-top-margin">
    <ul>
        <li>Declarative programming <br>
            <ul>
                <li>separates program description from evaluation</li>
                <li>standard loops aren’t reusable artifacts unless they’re abstracted with functions</li>
                <li>function parameters aren’t just scalar values but can also be functions themselves</li>
            </ul>
        </li>

        <li>Pure functions</li>
        <li>Referential transparency
            <span>consistently yields the same result on the same input</span>
        </li>
        <li>Immutability</li>
    </ul>
</div>

<div class="text-lg-left with-top-margin">
    <ul>
        <li>Encourage you to decompose tasks into simple functions</li>
        <li>composition (compose them back)-> higher-order function</li>
        <li>Process data using fluent chain-likes (compose, chain, pipeline)</li>
        <li>Decrease the complexity of event-driven code by enabling reactive paradigms</li>

    </ul>
</div>
